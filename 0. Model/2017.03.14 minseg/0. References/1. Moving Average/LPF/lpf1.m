close all
clearvars
clc

mdl.T.sample = 0.01;
load('bessel poles.mat')

%% [Init   ]: Motor: Encoder: angVel bessel filter: design parameters      
plant.mtr.encoder.filter.order    = 2;                  % [-] [integer] [ range: 02 : 10 ]
plant.mtr.encoder.filter.T.settle = mdl.T.sample * 2.5; % [s]

%% [Init   ]: Motor: Encoder: angVel bessel filter: transfer function      
% divide normalize poles by settling time
plant.mtr.encoder.filter.s.poles                                           ...
  = poly( s.pole.bessel{plant.mtr.encoder.filter.order}                    ...
        / plant.mtr.encoder.filter.T.settle                                ...
        );


% create transfer function
plant.mtr.encoder.filter.s.tf                                              ...
  = tf( plant.mtr.encoder.filter.s.poles(end)                              ...
      , plant.mtr.encoder.filter.s.poles                                   ...
      );
    
%{

% divide normalize poles by settling time
[plant.mtr.encoder.filter.s.B                                              ...
 plant.mtr.encoder.filter.s.A                                              ...
] = butter( plant.mtr.encoder.filter.order                                 ...
          , 2*mdl.T.sample/plant.mtr.encoder.filter.T.settle               ...
          );


% create transfer function
plant.mtr.encoder.filter.s.tf                                              ...
  = tf( plant.mtr.encoder.filter.s.B                                       ...
      , plant.mtr.encoder.filter.s.A                                       ...
      );


%}


% discretize transfer function
plant.mtr.encoder.filter.z.tf                                              ...
  =  c2d( plant.mtr.encoder.filter.s.tf                                    ...
        , mdl.T.sample                                                     ...
        );

% break transfer function into numerator and demonintor polynomials
[ plant.mtr.encoder.filter.s.num ...
, plant.mtr.encoder.filter.s.den ...
] = tfdata                       ...
( plant.mtr.encoder.filter.s.tf  ...
);

[ plant.mtr.encoder.filter.z.num ...
, plant.mtr.encoder.filter.z.den ...
] = tfdata                       ...
( plant.mtr.encoder.filter.z.tf  ...
);

% convert cells to matrices
plant.mtr.encoder.filter.s.num = plant.mtr.encoder.filter.s.num{:};
plant.mtr.encoder.filter.s.den = plant.mtr.encoder.filter.s.den{:};
plant.mtr.encoder.filter.z.num = plant.mtr.encoder.filter.z.num{:};
plant.mtr.encoder.filter.z.den = plant.mtr.encoder.filter.z.den{:};

%% [output]

bode( plant.mtr.encoder.filter.z.tf )
grid minor